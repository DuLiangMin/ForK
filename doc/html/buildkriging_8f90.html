<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ForK Library: buildkriging.f90 File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script src="../mathjax/MathJax.js">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ForK Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Types&#160;List</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions/Subroutines</a>  </div>
  <div class="headertitle">
<h1>buildkriging.f90 File Reference</h1>  </div>
</div>
<div class="contents">

<p>Subroutine to Build Kriging Surface based on Function Values.  
<a href="#_details">More...</a></p>

<p><a href="buildkriging_8f90_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buildkriging_8f90.html#aaf501f1c8267b05d845e22e90e126500">buildkriging</a> (ndim, ntot, X, Y, stot, H, beta, V, hyper, hyperflag, optflagi, covarflagi)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This subroutine creates a Kriging surface based on the supplied training data <em>X</em> and <em>Y</em>, with the parameters H, hyperflag, optflagi, covarflagi using to specify details of the construction process. The creation of the Kriging model is governed by the following steps:  <a href="#aaf501f1c8267b05d845e22e90e126500"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Subroutine to Build Kriging Surface based on Function Values. </p>

<p>Definition in file <a class="el" href="buildkriging_8f90_source.html">buildkriging.f90</a>.</p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="aaf501f1c8267b05d845e22e90e126500"></a><!-- doxytag: member="buildkriging.f90::buildkriging" ref="aaf501f1c8267b05d845e22e90e126500" args="(ndim, ntot, X, Y, stot, H, beta, V, hyper, hyperflag, optflagi, covarflagi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine buildkriging </td>
          <td>(</td>
          <td class="paramtype">integer,intent(in)&#160;</td>
          <td class="paramname"><em>ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer,intent(in)&#160;</td>
          <td class="paramname"><em>ntot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(8),dimension(ndim,ntot),intent(in)&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(8),dimension(ntot),intent(in)&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer,intent(in)&#160;</td>
          <td class="paramname"><em>stot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(8),dimension(stot,ntot),intent(in)&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(8),dimension(stot),intent(out)&#160;</td>
          <td class="paramname"><em>Beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(8),dimension(ntot),intent(out)&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(8),dimension(ndim+2),intent(out)&#160;</td>
          <td class="paramname"><em>hyper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer,intent(in)&#160;</td>
          <td class="paramname"><em>hyperflag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer,intent(in)&#160;</td>
          <td class="paramname"><em>optflagi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer,intent(in)&#160;</td>
          <td class="paramname"><em>covarflagi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This subroutine creates a Kriging surface based on the supplied training data <em>X</em> and <em>Y</em>, with the parameters H, hyperflag, optflagi, covarflagi using to specify details of the construction process. The creation of the Kriging model is governed by the following steps: </p>
<ol>
<li>
The fitting of model parameters (hyperparameters) based on maximization of the likelihood equation </li>
<li>
Creation of the Covariance Matrix </li>
<li>
Determination of the Optimal regression parameters </li>
<li>
Creation of the processed data <em>V</em> by inverting the covariance matrix and multiplying the difference between the training data and regression value by the inverse of the covariance matrix </li>
</ol>
<p>The Kriging model is built on the assumption that the data <em>Y</em> obey a Gaussian process with an assumed form for the mean function and the covariance between data points: </p>
<p class="formulaDsp">
\[ Y = N(m(\vec{x}), K(\vec{x},\vec{x}))\]
</p>
<p> where \(m(\vec{x})\) is the mean function and \(K(\vec{x},\vec{x})\) represents the covariance between function values. For this work, a regression mean function is assumed. Using this form, the mean function has the following form: </p>
<p class="formulaDsp">
\[ m(x) = h^{T}(\vec{x}) \beta \]
</p>
<p> where \(h^{T}(\vec{x})\) represents a column vector containing the basis functions of the basis evaluated at the points \(\vec{x}\). The regression parameters \(\beta\) are treated as part of the Kriging model and are determined while constructioning the model. Using this form of the mean function yields a Universal Kriging model. The case of a \(p=0\) regression (where the vector \(h(\vec{x})\) reduces to unity) is referred to as ordinary Kriging and is also covered by this functional form. The assumption of a vague prior on the regression parameters gives the following closed form for the parameters: </p>
<p class="formulaDsp">
\[ \beta=(H K^{-1} H^{T})^{-1} H^T K^{-1} Y = A^{-1} H^T K^{-1} Y \]
</p>
<p> where \(K\) is the covariance matrix between the training data. For a Kriging model, the covariance between function values is assumed to be only a function of the distance between points. The multi-dimension covariance function is constructed using a tensor product of one dimension functions. The multi-dimension covariance is calculated in subroutine <a href="namespacecovars.html#adb9de23578a8355229466a5dcd8e26e6covarfuncs">covarfunc</a>. The elements in ths covariance matrix are given as: </p>
<p class="formulaDsp">
\[ K_{i,j} = cov(y_{i},y_{j}) = \sigma^{2} k(\vec{X}_{i},\vec{X}_{j}; \theta) + \sigma^{2}_{n} \delta_{i,j} \]
</p>
<p> The parameters \(\sigma\) and \(\theta\) (and in some cases \(\sigma_{n}\)) are denoted as hyperparameters and are determined maximizing the likelihood equation for the Kriging model. This likelihood gives the probability that a Gaussian process with specified hyperparamters describes the training data <em>X</em> and <em>Y</em>. By picking the hyperparameters that maximize this probability, a Kriging model that best describes the data can be constructed. The hyperparameters can be determined in two different ways in this code. The first way is based on the Mean square error estimate and is computed in <a href="likelihood__mle_8f90.html">likelihood_mle</a>. For this method, the noise level \(\sigma_{n}\) is prescribed to ensure proper conditioning of the covariance matrix and the optimal covariance magnitude \(\sigma\) is determined in closed form. Hence, only the length scales \(\theta\) are determined through numerical optimization. This optimization is performed using a <a href="simplexsearch_8f90.html">simplex search</a> or <a href="patternsearch_8f90.html">pattern search</a>. The second way of determining hyperparameters is based on the likelihood equation for a gaussian process with a vague prior on the regression parameters. This likelihood is computed in <a href="likelihood_8f90.html">likelihood</a>. Using this equation, optimization is used to determine all of the parameters, including the covariance magnitude \(\sigma\) and noise \(\sigma_{n}\). This way of determining hyperparameters should be used when the noise level of the function needs to be fitted. <br/>
 With the regression and covariance parameters determined, the final processed data can be constructed using the inverse of the covariance matrix. To make predictions from the Kriging model, the following vector is required: </p>
<p class="formulaDsp">
\[ V = K^{-1} (Y - H^{T} \beta) \]
</p>
<p> where \( K \) is the covariance matrix, the product \(H^{T} \beta\) represents the mean function evaluated at the training points and \(Y\) represents the function values at the training points. Using this processed data, the regression parameters and covariance parameters, predictions can be made based on the Kriging model using: </p>
<ul>
<li>
<a href="krigingfuncpredict_8f90.html">krigingfuncpredict</a> </li>
<li>
<a href="krigingfuncvariance_8f90.html">krigingfuncvariance</a> </li>
<li>
<a href="kriginggradpredict_8f90.html">kriginggradpredict</a> </li>
<li>
<a href="kriginggradvariance_8f90.html">kriginggradvariance</a> </li>
</ul>
<dl class="author"><dt><b>Author:</b></dt><dd>Brian Lockwood <br/>
 Department of Mechanical Engineering <br/>
 University of Wyoming </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>May 1, 2012 </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in)</td><td><b>ndim</b> The dimension of the problem </td></tr>
    <tr><td class="paramname">in)</td><td><b>ntot </b>: The number of Training points </td></tr>
    <tr><td class="paramname">in)</td><td><b>X </b>: The location of the training points (size=[ndimxntot]) </td></tr>
    <tr><td class="paramname">in)</td><td><b>Y </b>: Funcation values for the training points (size=[ntot]) </td></tr>
    <tr><td class="paramname">in)</td><td><b>stot </b>: Number of Terms in the regression </td></tr>
    <tr><td class="paramname">in)</td><td><b>H</b>: The collocation matrix for the regression (size=[stotxntot]) </td></tr>
    <tr><td class="paramname">out)</td><td><b> beta</b>: Regression coefficients based on the optimal estimate for the Kriging model (size=[stot]) </td></tr>
    <tr><td class="paramname">out)</td><td><b>hyper</b>: Hyperparameters for the Kriging Model (size=[ndim+2]) <br/>
 </p>
<ul>
<li>
hyper(1:ndim) correspond to the length scale used in each dimension ( \(\theta\) in the covariance functions) </li>
<li>
hyper(ndim+1) is the magnitude of the covariance matrix </li>
<li>
hyper(ndim+2) is the fitted noise for the function evaluations </li>
</ul>
</td></tr>
    <tr><td class="paramname">out)</td><td><b>V</b>: Processed Training Data (size=[ntot]) <br/>
 In order to make predictions from the Kriging Model, the inverse of the covariance matrix onto the residual of the training data from the regression is all that is needed. To avoid re-computing and inverting the covariance matrix, the product is stored explicitly </td></tr>
    <tr><td class="paramname">in)</td><td><b>hyperflagi</b>: Flag to govern how the hyperparameters are selected <br/>
 </p>
<ul>
<li>
hyperflag=0 uses the likelihood formula to determine the length scale only <br/>
 The noise in the Function is hard-coded as a small value simply to ensure the covariance matrix is properly conditioned <br/>
 The magnitude for the covariance function is determined explicitly based on optimality for the likelihood function (Solve for magnitude when derivative of likelihood is set to zero) </li>
<li>
hyperflag=1 uses the likelihood formula based on all hyperparameters with no parameters determined by explicit relation <br/>
 All hyperparameters including noise and magnitude are determined via the optimization. Required when the amount of noise in the function evaluations is to be fitted. However, the dimension of the optimization problem is now higher so this will be slower.</li>
</ul>
</td></tr>
    <tr><td class="paramname">in)</td><td><b>optflagi</b>: Flag to govern the optimization algorithm used to determine the hyperparameters <br/>
 </p>
<ul>
<li>
optflag=0 Simplex Search (Nelder-Mead Method) to determine the hyperparameters <br/>
 Local optimization technique using simplex elements to determine search direction and line search to determine step sizes <br/>
 Fastest method but inherently sequential and may stall on local optimum </li>
<li>
optflag=1 Pattern Search used to determine hyperparameters <br/>
 Global optimization method with fixed search directions (forward and backward in each direction) <br/>
 Each iteration requires \(2*ndim\) likelihood evaluations; however, these may be performed in parallel using openmp (Each thread performs own likelihood evaluation so OMP_STACK_SIZE must be set large enough) <br/>
 </li>
</ul>
</td></tr>
    <tr><td class="paramname">in)</td><td><b>covarflagi</b>: Flag to govern which covariance function is used <br/>
 </p>
<ul>
<li>
covarflag==0 Uses Matern function with \(\nu=1/2\) </li>
<li>
covarflag==1 Uses Matern function with \(\nu=3/2\) </li>
<li>
covarflag==2 Uses Matern function with \(\nu=5/2\) </li>
</ul>
<p><br/>
 The parameter \(\nu\) governs the smoothness and differentiability of the covariance function. For function only Kriging, all three options are available. <br/>
 Good rule of thumb is to use the least smooth ( \(\nu=1/2\)) unless there is a reason to assume more smoothness in the data <br/>
 For small numbers of training points, higher \(\nu\) can improve accuracy </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">beta</td><td>Regression coefficients based on the optimal estimate for the Kriging model (size=[stot]) </td></tr>
    <tr><td class="paramname">hyper</td><td>Hyperparameters for the Kriging Model (size=[ndim+2]) </td></tr>
    <tr><td class="paramname">V</td><td>Processed Training Data (size=[ntot]) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="buildkriging_8f90_source.html#l00088">88</a> of file <a class="el" href="buildkriging_8f90_source.html">buildkriging.f90</a>.</p>

<p>References <a class="el" href="covars_8f90_source.html#l00014">covars::covarflag</a>, <a class="el" href="choleskymod_8f90_source.html#l00135">choleskymod::invertsymmetric()</a>, <a class="el" href="choleskymod_8f90_source.html#l00272">choleskymod::matrixmulttrans()</a>, <a class="el" href="choleskymod_8f90_source.html#l00346">choleskymod::matvec()</a>, <a class="el" href="choleskymod_8f90_source.html#l00416">choleskymod::matvectrans()</a>, <a class="el" href="opt_8f90_source.html#l00015">opt::optflag</a>, <a class="el" href="choleskymod_8f90_source.html#l00309">choleskymod::symmatrixmulttrans()</a>, <a class="el" href="choleskymod_8f90_source.html#l00381">choleskymod::symmatvec()</a>, and <a class="el" href="choleskymod_8f90_source.html#l00167">choleskymod::symmetricsolve()</a>.</p>

<p>Referenced by <a class="el" href="krigingwrapper_8f90_source.html#l00012">krigingwrapper()</a>.</p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>
Copyright (C) 2012 Brian A. Lockwood <br>
Generated on Tue May 1 2012 17:15:55 for Kriging Library
by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer"
							 src="doxygen.png"
							 alt="doxygen"/></a>
1.7.3
</small></address>
